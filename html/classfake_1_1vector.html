<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fake::vector: fake::vector&lt; T, Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">fake::vector
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>fake</b></li><li class="navelem"><a class="el" href="classfake_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfake_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fake::vector&lt; T, Alloc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector class. A copy of std::vector.  
 <a href="classfake_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fake_vector_8h_source.html">fakeVector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abbcade9efee0cb25d5c801099de99981"><td class="memItemLeft" align="right" valign="top"><a id="abbcade9efee0cb25d5c801099de99981"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:abbcade9efee0cb25d5c801099de99981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12496987133d30408fe2e0cd47d20c29"><td class="memItemLeft" align="right" valign="top"><a id="a12496987133d30408fe2e0cd47d20c29"></a>
typedef Alloc&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a12496987133d30408fe2e0cd47d20c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0287f76d70b14ce7371b3c31f8775bd8"><td class="memItemLeft" align="right" valign="top"><a id="a0287f76d70b14ce7371b3c31f8775bd8"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a0287f76d70b14ce7371b3c31f8775bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a01ce111a60ff82d241498b6ddd1a46"><td class="memItemLeft" align="right" valign="top"><a id="a8a01ce111a60ff82d241498b6ddd1a46"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a8a01ce111a60ff82d241498b6ddd1a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0088390bae81b7a6f0eb069f26666e23"><td class="memItemLeft" align="right" valign="top"><a id="a0088390bae81b7a6f0eb069f26666e23"></a>
typedef std::allocator_traits&lt; allocator_type &gt;::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a0088390bae81b7a6f0eb069f26666e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2956bbdf422d34c6f4a2c3ed68f999ed"><td class="memItemLeft" align="right" valign="top"><a id="a2956bbdf422d34c6f4a2c3ed68f999ed"></a>
typedef std::allocator_traits&lt; allocator_type &gt;::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a2956bbdf422d34c6f4a2c3ed68f999ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dde54cafc2ee964558722ec5a489f7"><td class="memItemLeft" align="right" valign="top"><a id="a35dde54cafc2ee964558722ec5a489f7"></a>
typedef __gnu_cxx::__normal_iterator&lt; pointer, <a class="el" href="classfake_1_1vector.html">vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a35dde54cafc2ee964558722ec5a489f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740ba3e62696efcb1bc381aef4a14e84"><td class="memItemLeft" align="right" valign="top"><a id="a740ba3e62696efcb1bc381aef4a14e84"></a>
typedef __gnu_cxx::__normal_iterator&lt; const_pointer, <a class="el" href="classfake_1_1vector.html">vector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a740ba3e62696efcb1bc381aef4a14e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbb8f858c9c091afefa2f2cdb744c5a"><td class="memItemLeft" align="right" valign="top"><a id="a2dbb8f858c9c091afefa2f2cdb744c5a"></a>
typedef std::reverse_iterator&lt; iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a2dbb8f858c9c091afefa2f2cdb744c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55879623bfe48d2e8e538000f8ec25c8"><td class="memItemLeft" align="right" valign="top"><a id="a55879623bfe48d2e8e538000f8ec25c8"></a>
typedef std::reverse_iterator&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a55879623bfe48d2e8e538000f8ec25c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab400ca25938692afc255744f10dbbd93"><td class="memItemLeft" align="right" valign="top"><a id="ab400ca25938692afc255744f10dbbd93"></a>
typedef std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:ab400ca25938692afc255744f10dbbd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640fdc9ee198e6751a2c7b1eda4abb63"><td class="memItemLeft" align="right" valign="top"><a id="a640fdc9ee198e6751a2c7b1eda4abb63"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a640fdc9ee198e6751a2c7b1eda4abb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a154ffc548c4e8e0684c6928ab0b7d753"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a154ffc548c4e8e0684c6928ab0b7d753">vector</a> (const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a154ffc548c4e8e0684c6928ab0b7d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor with a possible custom allocator.  <a href="#a154ffc548c4e8e0684c6928ab0b7d753">More...</a><br /></td></tr>
<tr class="separator:a154ffc548c4e8e0684c6928ab0b7d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec57e3a9ad5a085291f8ce5ba23465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a3dec57e3a9ad5a085291f8ce5ba23465">vector</a> (size_type n)</td></tr>
<tr class="memdesc:a3dec57e3a9ad5a085291f8ce5ba23465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with defined size. Allocates memory for n elements.  <a href="#a3dec57e3a9ad5a085291f8ce5ba23465">More...</a><br /></td></tr>
<tr class="separator:a3dec57e3a9ad5a085291f8ce5ba23465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5660b1ba62f11951f93eb603741c08a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a5660b1ba62f11951f93eb603741c08a3">vector</a> (size_type n, value_type val, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a5660b1ba62f11951f93eb603741c08a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with defined size, value and a possible custom allocator. Allocates memory for n elements and constructs n values val.  <a href="#a5660b1ba62f11951f93eb603741c08a3">More...</a><br /></td></tr>
<tr class="separator:a5660b1ba62f11951f93eb603741c08a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674cc1fdbef23b69831facc689209a93"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename  = std::_RequireInputIter&lt;InputIterator&gt;&gt; </td></tr>
<tr class="memitem:a674cc1fdbef23b69831facc689209a93"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a674cc1fdbef23b69831facc689209a93">vector</a> (InputIterator first, InputIterator last, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a674cc1fdbef23b69831facc689209a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with defined iterator range [first, last). Allocates memory for enough elements in this range and constructs them.  <a href="#a674cc1fdbef23b69831facc689209a93">More...</a><br /></td></tr>
<tr class="separator:a674cc1fdbef23b69831facc689209a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706c0c31eae10462a2e16f1cdfd8e665"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a706c0c31eae10462a2e16f1cdfd8e665">vector</a> (const <a class="el" href="classfake_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:a706c0c31eae10462a2e16f1cdfd8e665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a> type.  <a href="#a706c0c31eae10462a2e16f1cdfd8e665">More...</a><br /></td></tr>
<tr class="separator:a706c0c31eae10462a2e16f1cdfd8e665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d84ce09550fabd1fce9335f9de714c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a4d84ce09550fabd1fce9335f9de714c6">vector</a> (const <a class="el" href="classfake_1_1vector.html">vector</a> &amp;x, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:a4d84ce09550fabd1fce9335f9de714c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a> type with custom allocator.  <a href="#a4d84ce09550fabd1fce9335f9de714c6">More...</a><br /></td></tr>
<tr class="separator:a4d84ce09550fabd1fce9335f9de714c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae815b5ce700b2b1a816dd26351ba77f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aae815b5ce700b2b1a816dd26351ba77f">vector</a> (<a class="el" href="classfake_1_1vector.html">vector</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:aae815b5ce700b2b1a816dd26351ba77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a>.  <a href="#aae815b5ce700b2b1a816dd26351ba77f">More...</a><br /></td></tr>
<tr class="separator:aae815b5ce700b2b1a816dd26351ba77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0022ef48098e201c22cddbde25a8be7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ae0022ef48098e201c22cddbde25a8be7">vector</a> (<a class="el" href="classfake_1_1vector.html">vector</a> &amp;&amp;x, const allocator_type &amp;alloc)</td></tr>
<tr class="memdesc:ae0022ef48098e201c22cddbde25a8be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a> with custom allocator.  <a href="#ae0022ef48098e201c22cddbde25a8be7">More...</a><br /></td></tr>
<tr class="separator:ae0022ef48098e201c22cddbde25a8be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d76ee97b7b28f47a5ff953d3938b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a105d76ee97b7b28f47a5ff953d3938b1">vector</a> (std::initializer_list&lt; value_type &gt; il, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="memdesc:a105d76ee97b7b28f47a5ff953d3938b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for an initializer list with possible custom allocator. Allocates enough memory for elements in the list and constructs them.  <a href="#a105d76ee97b7b28f47a5ff953d3938b1">More...</a><br /></td></tr>
<tr class="separator:a105d76ee97b7b28f47a5ff953d3938b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2324daef35048187cd9552811756a86c"><td class="memItemLeft" align="right" valign="top"><a id="a2324daef35048187cd9552811756a86c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a2324daef35048187cd9552811756a86c">~vector</a> ()</td></tr>
<tr class="memdesc:a2324daef35048187cd9552811756a86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a>. <br /></td></tr>
<tr class="separator:a2324daef35048187cd9552811756a86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5339e17ed0f558b0b94009b45c3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfake_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a3ae5339e17ed0f558b0b94009b45c3c1">operator=</a> (const <a class="el" href="classfake_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:a3ae5339e17ed0f558b0b94009b45c3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assign operator for vector. Copies the properties and elements from vector on the right to the vector on the left.  <a href="#a3ae5339e17ed0f558b0b94009b45c3c1">More...</a><br /></td></tr>
<tr class="separator:a3ae5339e17ed0f558b0b94009b45c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7710f0e21f7531d24908bc82548f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfake_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a3f7710f0e21f7531d24908bc82548f2b">operator=</a> (<a class="el" href="classfake_1_1vector.html">vector</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a3f7710f0e21f7531d24908bc82548f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign operator. Moves the properties and elements from vector on the right to the vector on the left.  <a href="#a3f7710f0e21f7531d24908bc82548f2b">More...</a><br /></td></tr>
<tr class="separator:a3f7710f0e21f7531d24908bc82548f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c88fffd66b9f4b518098681050904b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfake_1_1vector.html">vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a7c88fffd66b9f4b518098681050904b6">operator=</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a7c88fffd66b9f4b518098681050904b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign operator for initializer list. Destroys previuosly held vector values. Creates a vector with initializer list values.  <a href="#a7c88fffd66b9f4b518098681050904b6">More...</a><br /></td></tr>
<tr class="separator:a7c88fffd66b9f4b518098681050904b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf161eda743ae8c669aa5be71f3ff8a7"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aaf161eda743ae8c669aa5be71f3ff8a7">begin</a> ()</td></tr>
<tr class="memdesc:aaf161eda743ae8c669aa5be71f3ff8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the start of the array.  <a href="#aaf161eda743ae8c669aa5be71f3ff8a7">More...</a><br /></td></tr>
<tr class="separator:aaf161eda743ae8c669aa5be71f3ff8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b27b92fd87317d279876243372fdfe"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aa8b27b92fd87317d279876243372fdfe">end</a> ()</td></tr>
<tr class="memdesc:aa8b27b92fd87317d279876243372fdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the end of the array.  <a href="#aa8b27b92fd87317d279876243372fdfe">More...</a><br /></td></tr>
<tr class="separator:aa8b27b92fd87317d279876243372fdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3567fd79465f31fe2bd26cb2eb85e2b"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ad3567fd79465f31fe2bd26cb2eb85e2b">begin</a> () const</td></tr>
<tr class="memdesc:ad3567fd79465f31fe2bd26cb2eb85e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_iterator to the start of the array.  <a href="#ad3567fd79465f31fe2bd26cb2eb85e2b">More...</a><br /></td></tr>
<tr class="separator:ad3567fd79465f31fe2bd26cb2eb85e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f745c7d40fc82937f201dd22cd95d8"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a76f745c7d40fc82937f201dd22cd95d8">end</a> () const</td></tr>
<tr class="memdesc:a76f745c7d40fc82937f201dd22cd95d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_iterator to the end of the array.  <a href="#a76f745c7d40fc82937f201dd22cd95d8">More...</a><br /></td></tr>
<tr class="separator:a76f745c7d40fc82937f201dd22cd95d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe60d8e10668ca0c3dab212e695ffc1"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a1fe60d8e10668ca0c3dab212e695ffc1">cbegin</a> () const</td></tr>
<tr class="memdesc:a1fe60d8e10668ca0c3dab212e695ffc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_iterator to the start of the array.  <a href="#a1fe60d8e10668ca0c3dab212e695ffc1">More...</a><br /></td></tr>
<tr class="separator:a1fe60d8e10668ca0c3dab212e695ffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764ef70912d85b94b0b130f33d8fd093"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a764ef70912d85b94b0b130f33d8fd093">cend</a> () const</td></tr>
<tr class="memdesc:a764ef70912d85b94b0b130f33d8fd093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_iterator to the end of the array.  <a href="#a764ef70912d85b94b0b130f33d8fd093">More...</a><br /></td></tr>
<tr class="separator:a764ef70912d85b94b0b130f33d8fd093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2476e1382bbf1ce2d799122f62b06b"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a7b2476e1382bbf1ce2d799122f62b06b">rbegin</a> ()</td></tr>
<tr class="memdesc:a7b2476e1382bbf1ce2d799122f62b06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator the end of the array.  <a href="#a7b2476e1382bbf1ce2d799122f62b06b">More...</a><br /></td></tr>
<tr class="separator:a7b2476e1382bbf1ce2d799122f62b06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3653b40c34a276138f7e09f8db45ead"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ad3653b40c34a276138f7e09f8db45ead">rend</a> ()</td></tr>
<tr class="memdesc:ad3653b40c34a276138f7e09f8db45ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator the start of the array.  <a href="#ad3653b40c34a276138f7e09f8db45ead">More...</a><br /></td></tr>
<tr class="separator:ad3653b40c34a276138f7e09f8db45ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c5a88df51f894685fde8dc6c033b5"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ab66c5a88df51f894685fde8dc6c033b5">rbegin</a> () const</td></tr>
<tr class="memdesc:ab66c5a88df51f894685fde8dc6c033b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_reverse iterator the end of the array.  <a href="#ab66c5a88df51f894685fde8dc6c033b5">More...</a><br /></td></tr>
<tr class="separator:ab66c5a88df51f894685fde8dc6c033b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964e3b45beb15c3883d544e4f27a605"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aa964e3b45beb15c3883d544e4f27a605">rend</a> () const</td></tr>
<tr class="memdesc:aa964e3b45beb15c3883d544e4f27a605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_reverse iterator the start of the array.  <a href="#aa964e3b45beb15c3883d544e4f27a605">More...</a><br /></td></tr>
<tr class="separator:aa964e3b45beb15c3883d544e4f27a605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8134189dd3977bd4037a10e6854ac9c"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#af8134189dd3977bd4037a10e6854ac9c">crbegin</a> () const</td></tr>
<tr class="memdesc:af8134189dd3977bd4037a10e6854ac9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_reverse iterator the end of the array.  <a href="#af8134189dd3977bd4037a10e6854ac9c">More...</a><br /></td></tr>
<tr class="separator:af8134189dd3977bd4037a10e6854ac9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf391e72aed746a40ac380aaf70a32d8"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#adf391e72aed746a40ac380aaf70a32d8">crend</a> () const</td></tr>
<tr class="memdesc:adf391e72aed746a40ac380aaf70a32d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_reverse iterator the start of the array.  <a href="#adf391e72aed746a40ac380aaf70a32d8">More...</a><br /></td></tr>
<tr class="separator:adf391e72aed746a40ac380aaf70a32d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad523b22d3c2200602a0b0439b69e6f46"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ad523b22d3c2200602a0b0439b69e6f46">size</a> () const</td></tr>
<tr class="memdesc:ad523b22d3c2200602a0b0439b69e6f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for current size of the vector.  <a href="#ad523b22d3c2200602a0b0439b69e6f46">More...</a><br /></td></tr>
<tr class="separator:ad523b22d3c2200602a0b0439b69e6f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c67c134cdc8d365af937918c9fc2a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a1c67c134cdc8d365af937918c9fc2a61">resize</a> (size_type n)</td></tr>
<tr class="memdesc:a1c67c134cdc8d365af937918c9fc2a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the vector. If the new size is lower or equal to the current size destroys out of range elements and the capacity stays untouched. If the size is greater than the current size allocates memory for n more elements.  <a href="#a1c67c134cdc8d365af937918c9fc2a61">More...</a><br /></td></tr>
<tr class="separator:a1c67c134cdc8d365af937918c9fc2a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41805c48307fdd9630c62dc1ca10259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ac41805c48307fdd9630c62dc1ca10259">resize</a> (size_type n, const value_type &amp;val)</td></tr>
<tr class="memdesc:ac41805c48307fdd9630c62dc1ca10259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the vector. If the new size is lower or equal to the current size destroys out of range elements and the capacity stays untouched. If the size is greater than the current size allocates memory and constructs n elements with value val.  <a href="#ac41805c48307fdd9630c62dc1ca10259">More...</a><br /></td></tr>
<tr class="separator:ac41805c48307fdd9630c62dc1ca10259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6314c74adfdadd78ade4d4db2ea3e15"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ac6314c74adfdadd78ade4d4db2ea3e15">capacity</a> () const</td></tr>
<tr class="memdesc:ac6314c74adfdadd78ade4d4db2ea3e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for current capacity of the vector.  <a href="#ac6314c74adfdadd78ade4d4db2ea3e15">More...</a><br /></td></tr>
<tr class="separator:ac6314c74adfdadd78ade4d4db2ea3e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbc8fb5844444c3d4d9d633aa4194d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#adbbc8fb5844444c3d4d9d633aa4194d2">empty</a> ()</td></tr>
<tr class="memdesc:adbbc8fb5844444c3d4d9d633aa4194d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vector is empty.  <a href="#adbbc8fb5844444c3d4d9d633aa4194d2">More...</a><br /></td></tr>
<tr class="separator:adbbc8fb5844444c3d4d9d633aa4194d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1390854cc51f7b83f4b871fe84b8015b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a1390854cc51f7b83f4b871fe84b8015b">reserve</a> (size_type n)</td></tr>
<tr class="memdesc:a1390854cc51f7b83f4b871fe84b8015b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the capacity of the array if n is greater than the current capacity, does nothing otherwise.  <a href="#a1390854cc51f7b83f4b871fe84b8015b">More...</a><br /></td></tr>
<tr class="separator:a1390854cc51f7b83f4b871fe84b8015b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ced26188db838294c117fc228aedb6"><td class="memItemLeft" align="right" valign="top"><a id="a73ced26188db838294c117fc228aedb6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a73ced26188db838294c117fc228aedb6">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a73ced26188db838294c117fc228aedb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the capacity to equal the size. <br /></td></tr>
<tr class="separator:a73ced26188db838294c117fc228aedb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec71da0fa184c234784f6895d8945d03"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aec71da0fa184c234784f6895d8945d03">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:aec71da0fa184c234784f6895d8945d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the [] operator to work like in an array.  <a href="#aec71da0fa184c234784f6895d8945d03">More...</a><br /></td></tr>
<tr class="separator:aec71da0fa184c234784f6895d8945d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd2d9852edba68b74b45a0309583b9e"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aabd2d9852edba68b74b45a0309583b9e">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:aabd2d9852edba68b74b45a0309583b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the [] operator to work like in an array.  <a href="#aabd2d9852edba68b74b45a0309583b9e">More...</a><br /></td></tr>
<tr class="separator:aabd2d9852edba68b74b45a0309583b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d69cf8d74039554ccde03a0be71ef14"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a1d69cf8d74039554ccde03a0be71ef14">at</a> (size_type n)</td></tr>
<tr class="memdesc:a1d69cf8d74039554ccde03a0be71ef14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to access an element in the array. Checks whether the requested element is the the range of the vector or not. If the element is out of range throws an std::out_of_range exception.  <a href="#a1d69cf8d74039554ccde03a0be71ef14">More...</a><br /></td></tr>
<tr class="separator:a1d69cf8d74039554ccde03a0be71ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471d597c2a40234bbe86179b97d0dcbf"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a471d597c2a40234bbe86179b97d0dcbf">at</a> (size_type n) const</td></tr>
<tr class="memdesc:a471d597c2a40234bbe86179b97d0dcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to access an element in the array. Checks whether the requested element is the the range of the vector or not. If the element is out of range throws an std::out_of_range exception.  <a href="#a471d597c2a40234bbe86179b97d0dcbf">More...</a><br /></td></tr>
<tr class="separator:a471d597c2a40234bbe86179b97d0dcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9e6a27783f8b72c203ae3fe7ad0859"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aaa9e6a27783f8b72c203ae3fe7ad0859">front</a> ()</td></tr>
<tr class="memdesc:aaa9e6a27783f8b72c203ae3fe7ad0859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the start of the array.  <a href="#aaa9e6a27783f8b72c203ae3fe7ad0859">More...</a><br /></td></tr>
<tr class="separator:aaa9e6a27783f8b72c203ae3fe7ad0859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0b97b9c2b8a83c6b3ee6865a61c25a"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a8b0b97b9c2b8a83c6b3ee6865a61c25a">front</a> () const</td></tr>
<tr class="memdesc:a8b0b97b9c2b8a83c6b3ee6865a61c25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_reference to the start of the array.  <a href="#a8b0b97b9c2b8a83c6b3ee6865a61c25a">More...</a><br /></td></tr>
<tr class="separator:a8b0b97b9c2b8a83c6b3ee6865a61c25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c67f42f60eb6ea322065aa6c87315b7"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a4c67f42f60eb6ea322065aa6c87315b7">back</a> ()</td></tr>
<tr class="memdesc:a4c67f42f60eb6ea322065aa6c87315b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the end of the array.  <a href="#a4c67f42f60eb6ea322065aa6c87315b7">More...</a><br /></td></tr>
<tr class="separator:a4c67f42f60eb6ea322065aa6c87315b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819b07f7862e65796d7457a6964f2ea4"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a819b07f7862e65796d7457a6964f2ea4">back</a> () const</td></tr>
<tr class="memdesc:a819b07f7862e65796d7457a6964f2ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const_reference to the end of the array.  <a href="#a819b07f7862e65796d7457a6964f2ea4">More...</a><br /></td></tr>
<tr class="separator:a819b07f7862e65796d7457a6964f2ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308cb3c0d13198a2a968a5239bf416a0"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a308cb3c0d13198a2a968a5239bf416a0">data</a> () const</td></tr>
<tr class="memdesc:a308cb3c0d13198a2a968a5239bf416a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the vector array.  <a href="#a308cb3c0d13198a2a968a5239bf416a0">More...</a><br /></td></tr>
<tr class="separator:a308cb3c0d13198a2a968a5239bf416a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ef51571cb66b677e3a05ff510a73a3"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename  = std::_RequireInputIter&lt;InputIterator&gt;&gt; </td></tr>
<tr class="memitem:a69ef51571cb66b677e3a05ff510a73a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a69ef51571cb66b677e3a05ff510a73a3">assign</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a69ef51571cb66b677e3a05ff510a73a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the vectors contents with the values in range [first, end).  <a href="#a69ef51571cb66b677e3a05ff510a73a3">More...</a><br /></td></tr>
<tr class="separator:a69ef51571cb66b677e3a05ff510a73a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e01bd25c0ee0bb10f6044d186c2fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a164e01bd25c0ee0bb10f6044d186c2fa">assign</a> (size_type n, const_reference val)</td></tr>
<tr class="memdesc:a164e01bd25c0ee0bb10f6044d186c2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the vectors contents with n number of values val.  <a href="#a164e01bd25c0ee0bb10f6044d186c2fa">More...</a><br /></td></tr>
<tr class="separator:a164e01bd25c0ee0bb10f6044d186c2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84afa1bde944ec3960a044387c34afde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a84afa1bde944ec3960a044387c34afde">assign</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a84afa1bde944ec3960a044387c34afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the vectors contents with the values in an initializer list.  <a href="#a84afa1bde944ec3960a044387c34afde">More...</a><br /></td></tr>
<tr class="separator:a84afa1bde944ec3960a044387c34afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aad69b6cb2986a6b31f965633a9998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a91aad69b6cb2986a6b31f965633a9998">push_back</a> (const value_type &amp;val)</td></tr>
<tr class="memdesc:a91aad69b6cb2986a6b31f965633a9998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value to the end of a vector.  <a href="#a91aad69b6cb2986a6b31f965633a9998">More...</a><br /></td></tr>
<tr class="separator:a91aad69b6cb2986a6b31f965633a9998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2532ed889fcf192d2f66080134d4470a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a2532ed889fcf192d2f66080134d4470a">push_back</a> (value_type &amp;&amp;val)</td></tr>
<tr class="memdesc:a2532ed889fcf192d2f66080134d4470a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a value to the end of a vector.  <a href="#a2532ed889fcf192d2f66080134d4470a">More...</a><br /></td></tr>
<tr class="separator:a2532ed889fcf192d2f66080134d4470a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f7b6d19a362439c3ef0b7baa2dcb8"><td class="memItemLeft" align="right" valign="top"><a id="a563f7b6d19a362439c3ef0b7baa2dcb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a563f7b6d19a362439c3ef0b7baa2dcb8">pop_back</a> ()</td></tr>
<tr class="memdesc:a563f7b6d19a362439c3ef0b7baa2dcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the last item in the vector. <br /></td></tr>
<tr class="separator:a563f7b6d19a362439c3ef0b7baa2dcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d09e69dcdbdcee51e53315a3c2c059e"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a1d09e69dcdbdcee51e53315a3c2c059e">insert</a> (const_iterator position, const value_type &amp;val)</td></tr>
<tr class="memdesc:a1d09e69dcdbdcee51e53315a3c2c059e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element with a value val to a position pointed by an iterator position.  <a href="#a1d09e69dcdbdcee51e53315a3c2c059e">More...</a><br /></td></tr>
<tr class="separator:a1d09e69dcdbdcee51e53315a3c2c059e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213241579c0b499ebfbfd139b24f7a60"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a213241579c0b499ebfbfd139b24f7a60">insert</a> (const_iterator position, value_type &amp;&amp;val)</td></tr>
<tr class="memdesc:a213241579c0b499ebfbfd139b24f7a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves and inserts an element with a value val to a position pointed by an iterator position.  <a href="#a213241579c0b499ebfbfd139b24f7a60">More...</a><br /></td></tr>
<tr class="separator:a213241579c0b499ebfbfd139b24f7a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e2fe207c2caffeeb59978b88b1ff3d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ae0e2fe207c2caffeeb59978b88b1ff3d">insert</a> (const_iterator position, size_type count, const value_type &amp;val)</td></tr>
<tr class="memdesc:ae0e2fe207c2caffeeb59978b88b1ff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts count number of elements with values val to a position pointed by an iterator position.  <a href="#ae0e2fe207c2caffeeb59978b88b1ff3d">More...</a><br /></td></tr>
<tr class="separator:ae0e2fe207c2caffeeb59978b88b1ff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29ca16087ee045eefbefcebadb50191"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , typename  = std::_RequireInputIter&lt;InputIterator&gt;&gt; </td></tr>
<tr class="memitem:ad29ca16087ee045eefbefcebadb50191"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ad29ca16087ee045eefbefcebadb50191">insert</a> (const_iterator position, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:ad29ca16087ee045eefbefcebadb50191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements from range [first, last) to a position pointed by an iterator position.  <a href="#ad29ca16087ee045eefbefcebadb50191">More...</a><br /></td></tr>
<tr class="separator:ad29ca16087ee045eefbefcebadb50191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4507d6807264094b8b033b1cce41313"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#aa4507d6807264094b8b033b1cce41313">insert</a> (const_iterator position, std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:aa4507d6807264094b8b033b1cce41313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the elements from an initializer list to a position pointed by an iterator position.  <a href="#aa4507d6807264094b8b033b1cce41313">More...</a><br /></td></tr>
<tr class="separator:aa4507d6807264094b8b033b1cce41313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f770760191adfcaab0f08dc29689d48"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a9f770760191adfcaab0f08dc29689d48">erase</a> (const_iterator position)</td></tr>
<tr class="memdesc:a9f770760191adfcaab0f08dc29689d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the vector pointed by the iterator position.  <a href="#a9f770760191adfcaab0f08dc29689d48">More...</a><br /></td></tr>
<tr class="separator:a9f770760191adfcaab0f08dc29689d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4f0fb6b42d2ec7107bb8194f4106c"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a22a4f0fb6b42d2ec7107bb8194f4106c">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:a22a4f0fb6b42d2ec7107bb8194f4106c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the elements in the range [first, last) from the vector pointed by the iterator position.  <a href="#a22a4f0fb6b42d2ec7107bb8194f4106c">More...</a><br /></td></tr>
<tr class="separator:a22a4f0fb6b42d2ec7107bb8194f4106c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac480f82e092e044293c38539b4db9430"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#ac480f82e092e044293c38539b4db9430">swap</a> (<a class="el" href="classfake_1_1vector.html">vector</a> &amp;x)</td></tr>
<tr class="memdesc:ac480f82e092e044293c38539b4db9430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the values and contents of two vectors.  <a href="#ac480f82e092e044293c38539b4db9430">More...</a><br /></td></tr>
<tr class="separator:ac480f82e092e044293c38539b4db9430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e78aea1924eda8e204a682b2715ce78"><td class="memItemLeft" align="right" valign="top"><a id="a5e78aea1924eda8e204a682b2715ce78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a5e78aea1924eda8e204a682b2715ce78">clear</a> ()</td></tr>
<tr class="memdesc:a5e78aea1924eda8e204a682b2715ce78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the vectors contents and sets the size to 0. <br /></td></tr>
<tr class="separator:a5e78aea1924eda8e204a682b2715ce78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d17690a8ec6dcbfcc3f02baad3f30"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:abc8d17690a8ec6dcbfcc3f02baad3f30"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#abc8d17690a8ec6dcbfcc3f02baad3f30">emplace</a> (const_iterator position, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abc8d17690a8ec6dcbfcc3f02baad3f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts and constructs an element to the position position.  <a href="#abc8d17690a8ec6dcbfcc3f02baad3f30">More...</a><br /></td></tr>
<tr class="separator:abc8d17690a8ec6dcbfcc3f02baad3f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b1615dab9508281f3270b5052567ee"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a00b1615dab9508281f3270b5052567ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a00b1615dab9508281f3270b5052567ee">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a00b1615dab9508281f3270b5052567ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts and constructs an element to the end of the vector.  <a href="#a00b1615dab9508281f3270b5052567ee">More...</a><br /></td></tr>
<tr class="separator:a00b1615dab9508281f3270b5052567ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbe6cb70f084552189f747b3130d86f"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfake_1_1vector.html#a1fbe6cb70f084552189f747b3130d86f">get_allocator</a> ()</td></tr>
<tr class="memdesc:a1fbe6cb70f084552189f747b3130d86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated to the vector.  <a href="#a1fbe6cb70f084552189f747b3130d86f">More...</a><br /></td></tr>
<tr class="separator:a1fbe6cb70f084552189f747b3130d86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class Alloc = std::allocator&lt;T&gt;&gt;<br />
class fake::vector&lt; T, Alloc &gt;</h3>

<p>Vector class. A copy of std::vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements to hold </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator for the vector </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a154ffc548c4e8e0684c6928ab0b7d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154ffc548c4e8e0684c6928ab0b7d753">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor with a possible custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>Custom allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dec57e3a9ad5a085291f8ce5ba23465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dec57e3a9ad5a085291f8ce5ba23465">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with defined size. Allocates memory for n elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Element count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5660b1ba62f11951f93eb603741c08a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5660b1ba62f11951f93eb603741c08a3">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with defined size, value and a possible custom allocator. Allocates memory for n elements and constructs n values val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>{ parameter_description } </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674cc1fdbef23b69831facc689209a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674cc1fdbef23b69831facc689209a93">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , typename  = std::_RequireInputIter&lt;InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with defined iterator range [first, last). Allocates memory for enough elements in this range and constructs them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to begin of range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to end of range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The allocator</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Class template type for iterator </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>{ description } </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a706c0c31eae10462a2e16f1cdfd8e665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706c0c31eae10462a2e16f1cdfd8e665">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a> type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d84ce09550fabd1fce9335f9de714c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d84ce09550fabd1fce9335f9de714c6">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a> type with custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae815b5ce700b2b1a816dd26351ba77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae815b5ce700b2b1a816dd26351ba77f">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0022ef48098e201c22cddbde25a8be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0022ef48098e201c22cddbde25a8be7">&#9670;&nbsp;</a></span>vector() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor for <a class="el" href="classfake_1_1vector.html" title="Vector class. A copy of std::vector. ">fake::vector</a> with custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to be moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a105d76ee97b7b28f47a5ff953d3938b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d76ee97b7b28f47a5ff953d3938b1">&#9670;&nbsp;</a></span>vector() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::<a class="el" href="classfake_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator_type &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>allocator_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for an initializer list with possible custom allocator. Allocates enough memory for elements in the list and constructs them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc</td><td>The allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a69ef51571cb66b677e3a05ff510a73a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ef51571cb66b677e3a05ff510a73a3">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , typename  = std::_RequireInputIter&lt;InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the vectors contents with the values in range [first, end). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Template parameter to only allow iterators to call this function. </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>{ description } </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a164e01bd25c0ee0bb10f6044d186c2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164e01bd25c0ee0bb10f6044d186c2fa">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the vectors contents with n number of values val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value of the elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84afa1bde944ec3960a044387c34afde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84afa1bde944ec3960a044387c34afde">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the vectors contents with the values in an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d69cf8d74039554ccde03a0be71ef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d69cf8d74039554ccde03a0be71ef14">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to access an element in the array. Checks whether the requested element is the the range of the vector or not. If the element is out of range throws an std::out_of_range exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index of an element in the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the n'th element in the vector. </dd></dl>

</div>
</div>
<a id="a471d597c2a40234bbe86179b97d0dcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471d597c2a40234bbe86179b97d0dcbf">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to access an element in the array. Checks whether the requested element is the the range of the vector or not. If the element is out of range throws an std::out_of_range exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index of an element in the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const_reference to the n'th element in the vector. </dd></dl>

</div>
</div>
<a id="a4c67f42f60eb6ea322065aa6c87315b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c67f42f60eb6ea322065aa6c87315b7">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the end of the array </dd></dl>

</div>
</div>
<a id="a819b07f7862e65796d7457a6964f2ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819b07f7862e65796d7457a6964f2ea4">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_reference to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_reference to the end of the array </dd></dl>

</div>
</div>
<a id="aaf161eda743ae8c669aa5be71f3ff8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf161eda743ae8c669aa5be71f3ff8a7">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator to the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the start of the array. </dd></dl>

</div>
</div>
<a id="ad3567fd79465f31fe2bd26cb2eb85e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3567fd79465f31fe2bd26cb2eb85e2b">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_iterator to the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator to the start of the array. </dd></dl>

</div>
</div>
<a id="ac6314c74adfdadd78ade4d4db2ea3e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6314c74adfdadd78ade4d4db2ea3e15">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for current capacity of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity. </dd></dl>

</div>
</div>
<a id="a1fe60d8e10668ca0c3dab212e695ffc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe60d8e10668ca0c3dab212e695ffc1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_iterator to the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator to the start of the array. </dd></dl>

</div>
</div>
<a id="a764ef70912d85b94b0b130f33d8fd093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764ef70912d85b94b0b130f33d8fd093">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_iterator to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator to the end of the array. </dd></dl>

</div>
</div>
<a id="af8134189dd3977bd4037a10e6854ac9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8134189dd3977bd4037a10e6854ac9c">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_reverse iterator the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_reverse iterator the end of the array. </dd></dl>

</div>
</div>
<a id="adf391e72aed746a40ac380aaf70a32d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf391e72aed746a40ac380aaf70a32d8">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_reverse iterator the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_reverse iterator the start of the array. </dd></dl>

</div>
</div>
<a id="a308cb3c0d13198a2a968a5239bf416a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308cb3c0d13198a2a968a5239bf416a0">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the vector array. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the vector array. </dd></dl>

</div>
</div>
<a id="abc8d17690a8ec6dcbfcc3f02baad3f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8d17690a8ec6dcbfcc3f02baad3f30">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts and constructs an element to the position position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the constructor of the element</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Arguments template</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator the inserted element. </dd></dl>

</div>
</div>
<a id="a00b1615dab9508281f3270b5052567ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b1615dab9508281f3270b5052567ee">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts and constructs an element to the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments to forward to the constructor of the element</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Arguments template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbbc8fb5844444c3d4d9d633aa4194d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbc8fb5844444c3d4d9d633aa4194d2">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the vector is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the vector is empty, False otherwise. </dd></dl>

</div>
</div>
<a id="aa8b27b92fd87317d279876243372fdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b27b92fd87317d279876243372fdfe">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the end of the array. </dd></dl>

</div>
</div>
<a id="a76f745c7d40fc82937f201dd22cd95d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f745c7d40fc82937f201dd22cd95d8">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_iterator to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_iterator to the end of the array. </dd></dl>

</div>
</div>
<a id="a9f770760191adfcaab0f08dc29689d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f770760191adfcaab0f08dc29689d48">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from the vector pointed by the iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the removed element. </dd></dl>

</div>
</div>
<a id="a22a4f0fb6b42d2ec7107bb8194f4106c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a4f0fb6b42d2ec7107bb8194f4106c">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the elements in the range [first, last) from the vector pointed by the iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first of the removes elements. </dd></dl>

</div>
</div>
<a id="aaa9e6a27783f8b72c203ae3fe7ad0859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9e6a27783f8b72c203ae3fe7ad0859">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the start of the array </dd></dl>

</div>
</div>
<a id="a8b0b97b9c2b8a83c6b3ee6865a61c25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0b97b9c2b8a83c6b3ee6865a61c25a">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_reference to the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_reference to the start of the array </dd></dl>

</div>
</div>
<a id="a1fbe6cb70f084552189f747b3130d86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbe6cb70f084552189f747b3130d86f">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator associated to the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The allocator. </dd></dl>

</div>
</div>
<a id="a1d09e69dcdbdcee51e53315a3c2c059e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d09e69dcdbdcee51e53315a3c2c059e">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element with a value val to a position pointed by an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted value. </dd></dl>

</div>
</div>
<a id="a213241579c0b499ebfbfd139b24f7a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213241579c0b499ebfbfd139b24f7a60">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves and inserts an element with a value val to a position pointed by an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the inserted value. </dd></dl>

</div>
</div>
<a id="ae0e2fe207c2caffeeb59978b88b1ff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e2fe207c2caffeeb59978b88b1ff3d">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts count number of elements with values val to a position pointed by an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first of the inserted elements. </dd></dl>

</div>
</div>
<a id="ad29ca16087ee045eefbefcebadb50191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29ca16087ee045eefbefcebadb50191">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIterator , typename  = std::_RequireInputIter&lt;InputIterator&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the elements from range [first, last) to a position pointed by an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to the start of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to the end of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Template argument to only allow iterators to pass </td></tr>
    <tr><td class="paramname">&lt;unnamed&gt;</td><td>{ description }</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first of the inserted elements </dd></dl>

</div>
</div>
<a id="aa4507d6807264094b8b033b1cce41313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4507d6807264094b8b033b1cce41313">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the elements from an initializer list to a position pointed by an iterator position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first of the inserted elements </dd></dl>

</div>
</div>
<a id="a3ae5339e17ed0f558b0b94009b45c3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae5339e17ed0f558b0b94009b45c3c1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">vector</a>&amp; <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assign operator for vector. Copies the properties and elements from vector on the right to the vector on the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector on the right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns reference to the copied vector. </dd></dl>

</div>
</div>
<a id="a3f7710f0e21f7531d24908bc82548f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7710f0e21f7531d24908bc82548f2b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">vector</a>&amp; <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assign operator. Moves the properties and elements from vector on the right to the vector on the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector on the right hand side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns reference to the copied vector. </dd></dl>

</div>
</div>
<a id="a7c88fffd66b9f4b518098681050904b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c88fffd66b9f4b518098681050904b6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfake_1_1vector.html">vector</a>&amp; <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign operator for initializer list. Destroys previuosly held vector values. Creates a vector with initializer list values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">il</td><td>The initializer list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the new vector. </dd></dl>

</div>
</div>
<a id="aec71da0fa184c234784f6895d8945d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec71da0fa184c234784f6895d8945d03">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the [] operator to work like in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index of an element in the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the n'th element in the vector. </dd></dl>

</div>
</div>
<a id="aabd2d9852edba68b74b45a0309583b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd2d9852edba68b74b45a0309583b9e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the [] operator to work like in an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Index of an element in the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const_reference to the n'th element in the vector. </dd></dl>

</div>
</div>
<a id="a91aad69b6cb2986a6b31f965633a9998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aad69b6cb2986a6b31f965633a9998">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a value to the end of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2532ed889fcf192d2f66080134d4470a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2532ed889fcf192d2f66080134d4470a">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a value to the end of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b2476e1382bbf1ce2d799122f62b06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2476e1382bbf1ce2d799122f62b06b">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse iterator the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator the end of the array. </dd></dl>

</div>
</div>
<a id="ab66c5a88df51f894685fde8dc6c033b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66c5a88df51f894685fde8dc6c033b5">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_reverse iterator the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_reverse iterator the end of the array. </dd></dl>

</div>
</div>
<a id="ad3653b40c34a276138f7e09f8db45ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3653b40c34a276138f7e09f8db45ead">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse iterator the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Reverse iterator the start of the array. </dd></dl>

</div>
</div>
<a id="aa964e3b45beb15c3883d544e4f27a605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa964e3b45beb15c3883d544e4f27a605">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const_reverse iterator the start of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Const_reverse iterator the start of the array. </dd></dl>

</div>
</div>
<a id="a1390854cc51f7b83f4b871fe84b8015b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1390854cc51f7b83f4b871fe84b8015b">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the capacity of the array if n is greater than the current capacity, does nothing otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c67c134cdc8d365af937918c9fc2a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c67c134cdc8d365af937918c9fc2a61">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the vector. If the new size is lower or equal to the current size destroys out of range elements and the capacity stays untouched. If the size is greater than the current size allocates memory for n more elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New vector size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41805c48307fdd9630c62dc1ca10259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41805c48307fdd9630c62dc1ca10259">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the vector. If the new size is lower or equal to the current size destroys out of range elements and the capacity stays untouched. If the size is greater than the current size allocates memory and constructs n elements with value val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>New vector size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to fill empty space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad523b22d3c2200602a0b0439b69e6f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad523b22d3c2200602a0b0439b69e6f46">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for current size of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Size. </dd></dl>

</div>
</div>
<a id="ac480f82e092e044293c38539b4db9430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480f82e092e044293c38539b4db9430">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Alloc  = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classfake_1_1vector.html">fake::vector</a>&lt; T, Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfake_1_1vector.html">vector</a>&lt; T, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the values and contents of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector to swap the contents with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="fake_vector_8h_source.html">fakeVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
